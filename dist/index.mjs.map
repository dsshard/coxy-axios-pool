{"version":3,"sources":["../src/any.ts","../src/index.ts"],"names":["PromiseAny","tasks","resolve","reject","errors","failureCount","task","err","createAxiosPool","initialOptions","configs","pool","AxiosPool","target","_target","name","url","data","options","instances","config","axios","abort","promises","client","json","result","response","instance","error","RpcAxiosPool","nodes","method","params"],"mappings":"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","file":"index.mjs","sourcesContent":["export const PromiseAny = <T>(tasks: readonly Promise<T>[]): Promise<T> => {\n  return new Promise<T>((resolve, reject) => {\n    if (tasks.length === 0) {\n      reject(new Error('All Promises rejected'))\n      return\n    }\n\n    const errors: unknown[] = []\n    let failureCount = 0\n\n    for (const task of tasks) {\n      Promise.resolve(task)\n        .then(resolve)\n        .catch((err) => {\n          errors.push(err)\n          failureCount++\n          if (failureCount === tasks.length) {\n            reject(new Error(errors.join('\\n')))\n          }\n        })\n    }\n  })\n}\n","import axios, { type AxiosInstance, type AxiosRequestConfig, type AxiosResponse } from 'axios'\nimport { PromiseAny } from './any'\n\nexport interface AxiosPoolConfig {\n  sendAll?: boolean\n  timeout?: number\n  validateResponse?: (response: AxiosResponse['data']) => void\n}\n\nexport function createAxiosPool(\n  initialOptions?: AxiosPoolConfig,\n  ...configs: Array<AxiosInstance | string>\n): AxiosInstance {\n  const pool = new AxiosPool(initialOptions, ...configs)\n  const target = {\n    get: (_target, name: keyof AxiosPool) => async (url: string, data, options: AxiosRequestConfig) => {\n      if (pool[name]) {\n        return pool[name](url, data, options)\n      }\n    },\n  }\n  return new Proxy({}, target)\n}\n\nexport class AxiosPool {\n  private readonly options: AxiosPoolConfig\n  private currentIndex = 0\n\n  private readonly pool: AxiosInstance[]\n\n  constructor(options?: AxiosPoolConfig, ...configs: Array<AxiosInstance | string>) {\n    const instances = []\n    for (const config of configs) {\n      if (typeof config === 'string') {\n        instances.push(axios.create({ baseURL: config }))\n      } else {\n        instances.push(config)\n      }\n    }\n    this.options = {\n      sendAll: options?.sendAll === undefined ? true : options.sendAll,\n      timeout: options?.timeout === undefined ? 0 : options?.timeout,\n      validateResponse: options?.validateResponse ? options?.validateResponse : () => Promise.resolve(),\n    }\n    this.pool = instances\n  }\n\n  public async get(url: string, options: AxiosRequestConfig): Promise<AxiosResponse> {\n    return this.request({\n      method: 'get',\n      url,\n      ...options,\n    })\n  }\n\n  public async post(url: string, data, options: AxiosRequestConfig): Promise<AxiosResponse> {\n    return this.request({\n      method: 'post',\n      data,\n      url,\n      ...options,\n    })\n  }\n\n  public async delete(url: string, data, options: AxiosRequestConfig): Promise<AxiosResponse> {\n    return this.request({\n      method: 'delete',\n      data,\n      url,\n      ...options,\n    })\n  }\n\n  public async put(url: string, data, options: AxiosRequestConfig): Promise<AxiosResponse> {\n    return this.request({\n      method: 'put',\n      data,\n      url,\n      ...options,\n    })\n  }\n\n  private async request(options: AxiosRequestConfig) {\n    if (this.options.sendAll) {\n      const abort = new AbortController()\n      const promises = []\n      for (const client of this.pool) {\n        promises.push(\n          client.request({\n            ...options,\n            signal: abort.signal,\n            transformResponse: [\n              (data) => {\n                let json: unknown\n                try {\n                  json = JSON.parse(data)\n                } catch {}\n\n                if (json) {\n                  this.options.validateResponse(json)\n                  return json\n                }\n                this.options.validateResponse(data)\n                return data\n              },\n            ],\n          }),\n        )\n      }\n\n      const result = PromiseAny(promises)\n      result\n        .then(async (response: AxiosResponse) => {\n          abort.abort()\n          return response\n        })\n        .catch(() => null)\n\n      return result\n    }\n\n    const instance = this.pool[this.currentIndex]\n    try {\n      const result = await instance.request(options)\n      this.options.validateResponse(result.data)\n      this.currentIndex = 0\n      return result\n    } catch (error) {\n      if (this.pool[this.currentIndex + 1]) {\n        if (this.options.timeout > 0) {\n          await new Promise((resolve) => setTimeout(resolve, this.options.timeout))\n        }\n        this.currentIndex += 1\n        return this.request(options)\n      }\n      this.currentIndex = 0\n      throw error\n    }\n  }\n}\n\nexport class RpcAxiosPool {\n  private readonly pool: AxiosInstance\n  private id = 0\n\n  constructor(nodes: Array<AxiosInstance | string>, options?: AxiosPoolConfig) {\n    this.pool = createAxiosPool(options, ...nodes)\n  }\n\n  // biome-ignore lint/suspicious/noExplicitAny: <any>\n  public async request(method: string, ...params: any): Promise<AxiosResponse> {\n    this.id += 1\n    return await this.pool.post('/', {\n      jsonrpc: '2.0',\n      id: this.id,\n      method,\n      params: params || [],\n    })\n  }\n}\n"]}